// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: campaigns.sql

package storage

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createCampaign = `-- name: CreateCampaign :one
INSERT INTO campaigns (
    advertiser_id,
    impressions_limit, clicks_limit,
    cost_per_impression, cost_per_click,
    ad_title, ad_text,
    start_date, end_date
) VALUES (
    $1::uuid,
    $2::bigint, $3::bigint,
    $4::decimal(10,2), $5::decimal(10,2),
    $6::varchar, $7::varchar,
    $8::int, $9::int
)
RETURNING id, advertiser_id, impressions_limit, clicks_limit, cost_per_impression, cost_per_click, ad_title, ad_text, start_date, end_date, pic_id
`

type CreateCampaignParams struct {
	AdvertiserID      uuid.UUID
	ImpressionsLimit  int64
	ClicksLimit       int64
	CostPerImpression pgtype.Numeric
	CostPerClick      pgtype.Numeric
	AdTitle           string
	AdText            string
	StartDate         int32
	EndDate           int32
}

func (q *Queries) CreateCampaign(ctx context.Context, arg CreateCampaignParams) (Campaign, error) {
	row := q.db.QueryRow(ctx, createCampaign,
		arg.AdvertiserID,
		arg.ImpressionsLimit,
		arg.ClicksLimit,
		arg.CostPerImpression,
		arg.CostPerClick,
		arg.AdTitle,
		arg.AdText,
		arg.StartDate,
		arg.EndDate,
	)
	var i Campaign
	err := row.Scan(
		&i.ID,
		&i.AdvertiserID,
		&i.ImpressionsLimit,
		&i.ClicksLimit,
		&i.CostPerImpression,
		&i.CostPerClick,
		&i.AdTitle,
		&i.AdText,
		&i.StartDate,
		&i.EndDate,
		&i.PicID,
	)
	return i, err
}

const createCampaignTargeting = `-- name: CreateCampaignTargeting :one
INSERT INTO campaigns_targeting (
    campaign_id,
    gender,
    age_from, age_to,
    location
) VALUES (
    $1::uuid,
    COALESCE($2::varchar, NULL),
    COALESCE($3::int, NULL), COALESCE($4::int, NULL),
    COALESCE($5::varchar, NULL)
)
RETURNING id, campaign_id, gender, age_from, age_to, location
`

type CreateCampaignTargetingParams struct {
	CampaignID uuid.UUID
	Gender     pgtype.Text
	AgeFrom    pgtype.Int4
	AgeTo      pgtype.Int4
	Location   pgtype.Text
}

func (q *Queries) CreateCampaignTargeting(ctx context.Context, arg CreateCampaignTargetingParams) (CampaignsTargeting, error) {
	row := q.db.QueryRow(ctx, createCampaignTargeting,
		arg.CampaignID,
		arg.Gender,
		arg.AgeFrom,
		arg.AgeTo,
		arg.Location,
	)
	var i CampaignsTargeting
	err := row.Scan(
		&i.ID,
		&i.CampaignID,
		&i.Gender,
		&i.AgeFrom,
		&i.AgeTo,
		&i.Location,
	)
	return i, err
}

const deleteCampaignByID = `-- name: DeleteCampaignByID :exec
DELETE FROM campaigns
WHERE id = $1::uuid
`

func (q *Queries) DeleteCampaignByID(ctx context.Context, campaignID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteCampaignByID, campaignID)
	return err
}

const getCampaignPicID = `-- name: GetCampaignPicID :one
SELECT pic_id FROM campaigns
WHERE id = $1::uuid
`

func (q *Queries) GetCampaignPicID(ctx context.Context, campaignID uuid.UUID) (pgtype.Text, error) {
	row := q.db.QueryRow(ctx, getCampaignPicID, campaignID)
	var pic_id pgtype.Text
	err := row.Scan(&pic_id)
	return pic_id, err
}

const getCampaignWithTargetingByID = `-- name: GetCampaignWithTargetingByID :one
SELECT campaigns.id, advertiser_id, impressions_limit, clicks_limit, cost_per_impression, cost_per_click, ad_title, ad_text, start_date, end_date, pic_id, campaigns_targeting.id, campaign_id, gender, age_from, age_to, location FROM campaigns JOIN campaigns_targeting ON campaigns.id = campaigns_targeting.campaign_id
WHERE campaigns.id = $1::uuid
`

type GetCampaignWithTargetingByIDRow struct {
	ID                uuid.UUID
	AdvertiserID      uuid.UUID
	ImpressionsLimit  int64
	ClicksLimit       int64
	CostPerImpression pgtype.Numeric
	CostPerClick      pgtype.Numeric
	AdTitle           string
	AdText            string
	StartDate         int32
	EndDate           int32
	PicID             pgtype.Text
	ID_2              uuid.UUID
	CampaignID        uuid.UUID
	Gender            pgtype.Text
	AgeFrom           pgtype.Int4
	AgeTo             pgtype.Int4
	Location          pgtype.Text
}

func (q *Queries) GetCampaignWithTargetingByID(ctx context.Context, campaignID uuid.UUID) (GetCampaignWithTargetingByIDRow, error) {
	row := q.db.QueryRow(ctx, getCampaignWithTargetingByID, campaignID)
	var i GetCampaignWithTargetingByIDRow
	err := row.Scan(
		&i.ID,
		&i.AdvertiserID,
		&i.ImpressionsLimit,
		&i.ClicksLimit,
		&i.CostPerImpression,
		&i.CostPerClick,
		&i.AdTitle,
		&i.AdText,
		&i.StartDate,
		&i.EndDate,
		&i.PicID,
		&i.ID_2,
		&i.CampaignID,
		&i.Gender,
		&i.AgeFrom,
		&i.AgeTo,
		&i.Location,
	)
	return i, err
}

const getCampaignsWithTargetingByAdvertiserID = `-- name: GetCampaignsWithTargetingByAdvertiserID :many
SELECT campaigns.id, advertiser_id, impressions_limit, clicks_limit, cost_per_impression, cost_per_click, ad_title, ad_text, start_date, end_date, pic_id, campaigns_targeting.id, campaign_id, gender, age_from, age_to, location FROM campaigns JOIN campaigns_targeting ON campaigns.id = campaigns_targeting.campaign_id
WHERE advertiser_id = $3::uuid
LIMIT $1 OFFSET $2
`

type GetCampaignsWithTargetingByAdvertiserIDParams struct {
	Limit        int32
	Offset       int32
	AdvertiserID uuid.UUID
}

type GetCampaignsWithTargetingByAdvertiserIDRow struct {
	ID                uuid.UUID
	AdvertiserID      uuid.UUID
	ImpressionsLimit  int64
	ClicksLimit       int64
	CostPerImpression pgtype.Numeric
	CostPerClick      pgtype.Numeric
	AdTitle           string
	AdText            string
	StartDate         int32
	EndDate           int32
	PicID             pgtype.Text
	ID_2              uuid.UUID
	CampaignID        uuid.UUID
	Gender            pgtype.Text
	AgeFrom           pgtype.Int4
	AgeTo             pgtype.Int4
	Location          pgtype.Text
}

func (q *Queries) GetCampaignsWithTargetingByAdvertiserID(ctx context.Context, arg GetCampaignsWithTargetingByAdvertiserIDParams) ([]GetCampaignsWithTargetingByAdvertiserIDRow, error) {
	rows, err := q.db.Query(ctx, getCampaignsWithTargetingByAdvertiserID, arg.Limit, arg.Offset, arg.AdvertiserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCampaignsWithTargetingByAdvertiserIDRow
	for rows.Next() {
		var i GetCampaignsWithTargetingByAdvertiserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.AdvertiserID,
			&i.ImpressionsLimit,
			&i.ClicksLimit,
			&i.CostPerImpression,
			&i.CostPerClick,
			&i.AdTitle,
			&i.AdText,
			&i.StartDate,
			&i.EndDate,
			&i.PicID,
			&i.ID_2,
			&i.CampaignID,
			&i.Gender,
			&i.AgeFrom,
			&i.AgeTo,
			&i.Location,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRelativeAd = `-- name: GetRelativeAd :one
SELECT campaigns.id, campaigns.advertiser_id, impressions_limit, clicks_limit, cost_per_impression, cost_per_click, ad_title, ad_text, start_date, end_date, pic_id, campaigns_targeting.id, campaign_id, gender, age_from, age_to, location, client_id, ml_scores.advertiser_id, score, 
    (score * cost_per_click + (1 - score) * cost_per_impression) AS expected_revenue
FROM campaigns 
JOIN campaigns_targeting ON campaigns.id = campaigns_targeting.campaign_id
JOIN ml_scores ON campaigns.advertiser_id = ml_scores.advertiser_id
WHERE 
    NOT EXISTS (
        SELECT 1 FROM impressions 
        WHERE impressions.campaign_id = campaigns.id 
          AND impressions.client_id = $1::uuid
    ) AND
    (
        SELECT COUNT(*) FROM impressions 
        WHERE impressions.campaign_id = campaigns.id
    ) < campaigns.impressions_limit
    AND
    (gender = $2::varchar OR gender = 'ALL' OR gender IS NULL) AND
    (
        ((age_from IS NULL AND age_to >= $3::int) OR 
         (age_to IS NULL AND age_from <= $3::int) OR 
         (age_from IS NULL AND age_to IS NULL)) OR
        (age_from <= $3::int AND age_to >= $3::int)
    ) AND
    (location IS NULL OR location = $4::varchar) AND
    ml_scores.client_id = $1::uuid AND
    campaigns.start_date <= $5::int AND 
    campaigns.end_date >= $5::int
ORDER BY expected_revenue DESC
LIMIT 1
`

type GetRelativeAdParams struct {
	ClientID uuid.UUID
	Gender   string
	Age      int32
	Location string
	CurDate  int32
}

type GetRelativeAdRow struct {
	ID                uuid.UUID
	AdvertiserID      uuid.UUID
	ImpressionsLimit  int64
	ClicksLimit       int64
	CostPerImpression pgtype.Numeric
	CostPerClick      pgtype.Numeric
	AdTitle           string
	AdText            string
	StartDate         int32
	EndDate           int32
	PicID             pgtype.Text
	ID_2              uuid.UUID
	CampaignID        uuid.UUID
	Gender            pgtype.Text
	AgeFrom           pgtype.Int4
	AgeTo             pgtype.Int4
	Location          pgtype.Text
	ClientID          uuid.UUID
	AdvertiserID_2    uuid.UUID
	Score             int32
	ExpectedRevenue   int32
}

func (q *Queries) GetRelativeAd(ctx context.Context, arg GetRelativeAdParams) (GetRelativeAdRow, error) {
	row := q.db.QueryRow(ctx, getRelativeAd,
		arg.ClientID,
		arg.Gender,
		arg.Age,
		arg.Location,
		arg.CurDate,
	)
	var i GetRelativeAdRow
	err := row.Scan(
		&i.ID,
		&i.AdvertiserID,
		&i.ImpressionsLimit,
		&i.ClicksLimit,
		&i.CostPerImpression,
		&i.CostPerClick,
		&i.AdTitle,
		&i.AdText,
		&i.StartDate,
		&i.EndDate,
		&i.PicID,
		&i.ID_2,
		&i.CampaignID,
		&i.Gender,
		&i.AgeFrom,
		&i.AgeTo,
		&i.Location,
		&i.ClientID,
		&i.AdvertiserID_2,
		&i.Score,
		&i.ExpectedRevenue,
	)
	return i, err
}

const setCampaignPicture = `-- name: SetCampaignPicture :exec
UPDATE campaigns
SET
    pic_id = $1::varchar
WHERE
    id = $2::uuid
`

type SetCampaignPictureParams struct {
	PictureID  string
	CampaignID uuid.UUID
}

func (q *Queries) SetCampaignPicture(ctx context.Context, arg SetCampaignPictureParams) error {
	_, err := q.db.Exec(ctx, setCampaignPicture, arg.PictureID, arg.CampaignID)
	return err
}

const updateCampaign = `-- name: UpdateCampaign :one
UPDATE campaigns
SET
    impressions_limit = $1::bigint, clicks_limit = $2::bigint,
    cost_per_impression = $3::decimal(10,2), cost_per_click = $4::decimal(10,2),
    ad_title = $5::varchar, ad_text = $6::varchar,
    start_date = $7::int, end_date = $8::int
WHERE
    id = $9::uuid
RETURNING id, advertiser_id, impressions_limit, clicks_limit, cost_per_impression, cost_per_click, ad_title, ad_text, start_date, end_date, pic_id
`

type UpdateCampaignParams struct {
	ImpressionsLimit  int64
	ClicksLimit       int64
	CostPerImpression pgtype.Numeric
	CostPerClick      pgtype.Numeric
	AdTitle           string
	AdText            string
	StartDate         int32
	EndDate           int32
	CampaignID        uuid.UUID
}

func (q *Queries) UpdateCampaign(ctx context.Context, arg UpdateCampaignParams) (Campaign, error) {
	row := q.db.QueryRow(ctx, updateCampaign,
		arg.ImpressionsLimit,
		arg.ClicksLimit,
		arg.CostPerImpression,
		arg.CostPerClick,
		arg.AdTitle,
		arg.AdText,
		arg.StartDate,
		arg.EndDate,
		arg.CampaignID,
	)
	var i Campaign
	err := row.Scan(
		&i.ID,
		&i.AdvertiserID,
		&i.ImpressionsLimit,
		&i.ClicksLimit,
		&i.CostPerImpression,
		&i.CostPerClick,
		&i.AdTitle,
		&i.AdText,
		&i.StartDate,
		&i.EndDate,
		&i.PicID,
	)
	return i, err
}

const updateCampaignTargeting = `-- name: UpdateCampaignTargeting :one
UPDATE campaigns_targeting
SET
    gender = COALESCE($1::varchar, NULL),
    age_from = COALESCE($2::int, NULL), age_to = COALESCE($3::int, NULL),
    location = COALESCE($4::varchar, NULL)
WHERE
    campaign_id = $5::uuid
RETURNING id, campaign_id, gender, age_from, age_to, location
`

type UpdateCampaignTargetingParams struct {
	Gender     pgtype.Text
	AgeFrom    pgtype.Int4
	AgeTo      pgtype.Int4
	Location   pgtype.Text
	CampaignID uuid.UUID
}

func (q *Queries) UpdateCampaignTargeting(ctx context.Context, arg UpdateCampaignTargetingParams) (CampaignsTargeting, error) {
	row := q.db.QueryRow(ctx, updateCampaignTargeting,
		arg.Gender,
		arg.AgeFrom,
		arg.AgeTo,
		arg.Location,
		arg.CampaignID,
	)
	var i CampaignsTargeting
	err := row.Scan(
		&i.ID,
		&i.CampaignID,
		&i.Gender,
		&i.AgeFrom,
		&i.AgeTo,
		&i.Location,
	)
	return i, err
}
